# design-pattern
书名：《Head First 设计模式》
作者：Eric Freeman & Elisabeth Freeman & Kathy Sierra & Bert Bates
翻译：O'Reilly Taiwan公司

# 设计原则：
    1. 封装变化 - 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。
    2. 多用组合，少用继承
    3. 针对接口编程，不针对实现编程
    4. 为交互对象之间的松耦合设计而努力
    5. 对扩展开放，对修改关闭（开放-关闭原则）
    6. 依赖抽象，不要依赖具体类（依赖倒置原则）
    7. 最少知识原则：只和朋友交谈
    8. 好莱坞原则：别调用（打电话给）我们，我们会调用（打电话给）你

# 设计模式对应英文：
    策略模式：the Strategy Pattern
    观察者模式：the Observer Pattern
    装饰者模式：the Decorator Pattern
    工厂模式：the Factory Pattern
    单件模式（单例模式）：the Singleton Pattern
    命令模式：the Command Pattern
    适配器模式：the Adapter Pattern
    外观模式：the Facade Pattern
    模板方法模式：the Template Method Pattern
    迭代器模式：the Iterator Pattern
    组合模式：the Composite Pattern
    状态模式：the State Pattern
    代理模式：the Proxy Pattern
    复合模式：Compound Patterns

# 设计模式定义：
    策略模式 - 定义算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。
    观察者模式 - 在对象之间定义一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象都会收到通知，并自动更新。
    装饰者模式 - 动态的将责任附加到对象上。想要扩展功能，装饰者提供有别于继承的另一种选择。
    工厂方法模式 - 定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。
    抽象工厂模式 - 提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。
    单件模式（单例模式）- 确保一个类只有一个实例，并提供全局访问点。
    命令模式 - 将请求封装成对象，这可以让你使用不同的请求、队列，或者日志请求来参数化其他对象。命令模式也可以支持撤销操作。
    适配器模式 - 将一个类的接口，转换成客户期望的另一个接口。适配器让原本不兼容的类可以合作无间。
    外观模式 - 提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。
    模板方法模式 - 在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。
